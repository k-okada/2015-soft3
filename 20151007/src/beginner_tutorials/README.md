1-1)
参考website
http://myenigma.hatenablog.com/entry/20131229/1388320084

ビルドシステムとは、ソースコードから、エンドユーザが使用できる“目的物”を生成するものです。
ROSではcatkinという独自のビルドシステムを使用しています。
これはCMakeを拡張したものであり、パッケージ間の依存関係を管理できるようにしたものです。
GNU Makeでは”Makefile”として保存されているものがCMakeでは”CmakeLists.txt”として、保存されている。

http://wiki.ros.org/catkin/commands/catkin_make

ou should always call catkin_make in the root of your catkin workspace, assuming your catkin workspace is in ~/catkin_ws:

    $ cd ~/catkin_ws
    $ catkin_make

The above command will build any packages located in ~/catkin_ws/src. The equivalent commands to do this manually would be:

    $ cd ~/catkin_ws
    $ cd src
    $ catkin_init_workspace
    $ cd ..
    $ mkdir build
    $ cd build
    $ cmake ../src -DCMAKE_INSTALL_PREFIX=../install -DCATKIN_DEVEL_PREFIX=../devel
    $ make

つまりcatkin_makeによってcmake+makeが一気に行えるとわかった


1-2)
http://wiki.ros.org/ja/ROS/Tutorials/WritingPublisherSubscriber%28python%29
CMakeをビルドシステムとして採用しているので、Pythonノードの場合でも同じようにCMakeを使わなければなりません。これは、メッセージとサービスのための自動生成されるPythonコードを確実に作るためです。 

1-3)
http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning
In this application all user callbacks will be called from within the ros::spin() call.
ros::spinOnce() will call all the callbacks waiting to be called at that point in time. 

http://answers.ros.org/question/65735/is-spinonce-needed/
If you have an infinite loop of your own that does some processing, use spinOnce() somewhere in the loop. This allows ROS to process the callbacks for queued messages - if you don't include it, your callbacks will never be called and none of your messages will be published.

If all your calculations are performed in callbacks and you don't need an infinite loop for your custom processing, just use spin() which continuously pumps for callbacks.

どちらもコールバックを呼ぶ関数である。
ros::Spin()は、ノードが閉じられるまでコールバック関数を呼びつづけるのに対し、ros::SpinOnce()は一度だけコールバック関数を呼ぶ


1-4)
http://wiki.ros.org/ja/actionlib
For the DoDishes.action, the following messages are generated by genaction.py:

    DoDishesAction.msg

    DoDishesActionGoal.msg

    DoDishesActionResult.msg

    DoDishesActionFeedback.msg

    DoDishesGoal.msg

    DoDishesResult.msg

    DoDishesFeedback.msg

ほかにも生成されるものがあるのかわかりませんでした

2)操作しました。押しすぎるとロボットが画面外に出てしまって、難しかったです。
3)
mech-user@test1-pc:/opt/ros/indigo/lib/kobuki_keyop$ rosnode info /keyop 
--------------------------------------------------------------------------------
Node [/keyop]
Publications: 
 * /mobile_base/commands/velocity [geometry_msgs/Twist]
 * /rosout [rosgraph_msgs/Log]
 * /mobile_base/commands/motor_power [kobuki_msgs/MotorPower]

Subscriptions: 
 * /keyop/teleop [unknown type]
 * /clock [rosgraph_msgs/Clock]

Services: 
 * /keyop/get_loggers
 * /keyop/set_logger_level


contacting node http://test1-pc:54003/ ...
Pid: 26220
Connections:
 * topic: /rosout
    * to: /rosout
    * direction: outbound
    * transport: TCPROS
 * topic: /mobile_base/commands/velocity
    * to: /gazebo
    * direction: outbound
    * transport: TCPROS
 * topic: /mobile_base/commands/motor_power
    * to: /gazebo
    * direction: outbound
    * transport: TCPROS
 * topic: /clock
    * to: /gazebo (http://test1-pc:47413/)
    * direction: inbound
    * transport: TCPROS

よって
 トピック/mobile_base/commands/velocity に対するメッセージは[geometry_msgs/Twist]
 トピック/rosout　に対するメッセージは [rosgraph_msgs/Log]
 トピック/mobile_base/commands/motor_powerに対するメッセージは [kobuki_msgs/MotorPower]



4)ソース
#!/usr/bin/env python

import rospy
from geometry_msgs.msg import Twist

def my_keyop():
	rospy.init_node('vel_publisher')
	pub = rospy.Publisher('/mobile_base/commands/velocity', Twist, queue_size = 10)

	while not rospy.is_shutdown():
    		vel = Twist()
    		new_input = raw_input('p, r, h, m, q: ')
    		if 'p' in new_input:
        		vel.linear.x = 0.5
	    	if 'r' in new_input:
			vel.linear.x = -0.5
	    	if 'h' in new_input:
			vel.angular.z = 1.0
	   	if 'm' in new_input:
			vel.angular.z = -1.0
	    	if 'q' in new_input:
			break
	    	print vel
	    	pub.publish(vel)


if __name__ == '__main__':
	my_keyop()


実際に動いた
5)できました。(http://wiki.ros.org/ja/turtlebot_simulator/Tutorials/hydro/Make%20a%20map%20and%20navigate%20with%20it を参考に)

6)mech-user@test1-pc:/opt/ros/indigo/share/move_base_msgs/action$ cat MoveBase.action
geometry_msgs/PoseStamped target_pose
---
---
geometry_msgs/PoseStamped base_position


http://wiki.ros.org/move_base
The move_base node provides an implementation of the SimpleActionServer (see actionlib documentation), that takes in goals containing geometry_msgs/PoseStamped messages. You can communicate with the move_base node over ROS directly, but the recommended way to send goals to move_base if you care about tracking their status is by using the SimpleActionClient. Please see actionlib documentation for more information.

Action Subscribed Topics

move_base/goal (move_base_msgs/MoveBaseActionGoal)

A goal for move_base to pursue in the world.
move_base/cancel (actionlib_msgs/GoalID)
A request to cancel a specific goal.

Action Published Topics

move_base/feedback (move_base_msgs/MoveBaseActionFeedback)

Feedback contains the current position of the base in the world.
move_base/status (actionlib_msgs/GoalStatusArray)
Provides status information on the goals that are sent to the move_base action.
move_base/result (move_base_msgs/MoveBaseActionResult)
Result is empty for the move_base action.

必要そうな情報は得られたが、どれが使われているのかいまいちわからなかった





